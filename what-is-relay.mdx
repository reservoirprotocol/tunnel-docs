---
title: What is Relay?
description: "The fastest and cheapest way to bridge & transact across chains"
---

Relay enables instant, low-cost bridging and cross-chain execution. It is designed to minimize cost and latency, making it ideal for price-sensitive applications, such as payments, bridging and gas abstraction.

It features the following key properties:

- **Fast**: Orders can be filled optimistically, even before payment is confirmed. Small payments can confirm in seconds.
- **Cheap**: As much logic as possible is performed off chain to reduce costs.
- **Lightweight**: Can operate on any chain with just a single relayer

## How does it work?

Relay is powered by relayers. When a user wishes to bridge, they submit an order and a transfer to the relayer, who validates the order and sends the funds to the user on the destination chain. Relayers maintain a balance on all chains in order to make executions, and then periodically rebalances to ensure there is sufficient liquidity on all chains. In the rare case of a transaction failure, relayers refunds the user directly as soon as possible.

## How is it so fast?

In traditional message-based bridges (LayerZero, Axelar, Wormhole, etc), there needs to be consensus amongst a group of actors that something happened on Chain A, before it can be acted upon on Chain B. This is because there are often shared liquidity pools on either side, and so you need to be certain that the action on Chain A was completed. For safety, this usually takes at least a couple of minutes.

By contrast, when using a relayer model (Relay, Across, etc), a single relayer executes the order on Chain B using their own funds. This means they don’t need to wait for the action on Chain A to be fully confirmed, or to get consensus. They could even fill while the tx is in the mempool on Chain A if they were willing to take the confirmation risk, which is reasonable for low cost actions like NFT mints and gas sponsorship.

## How is it so cheap?

When bridging or swapping, there are typically three cost components:

- **Asset transfer**: Moving assets from one wallet to another
- **Order validation**: Ensuring that the user’s order was fulfilled correctly
- **Fee collection**: Paying fees to actors such as a protocol, wallet or relayer

In most systems, order validation and fee collection happen on the same chain as asset transfer, which is usually a high-cost chain like Ethereum. In Relay, order validation and fee collection are off chain, while asset transfers are reduced to _direct_ transfers between the user and the relayer. This avoids the gas required when routing assets through onchain protocols. This reduces the cost to the absolute minimum possible.

## How do you support so many chains?

In many systems, expanding to a new chain requires deploying contracts, getting consensus amongst a network of actors, or deploying liquidity pools. With Relay, you just need a single relayer (Reservoir) who is willing to operate on a chain, and it’s permissionless for them to get started. This is critical in a world with an abundance of chains. If you are interested in having your chain supported, reach out!

## Is it trustless?

Not yet! We are hard at work developing the Relay protocol, a trustless system that allows users to interact with a permissionless set of relayers. However today, Relay is powered by [Reservoir](https://reservoir.tools/) who is responsible for both order validation & relaying. We have mechanics in place to make sure orders are filled, and funds allocated in case of transaction failure. If you are interested in an enterprise agreement, please reach out.

## Use Cases

Learn more about the powerful use cases that can be built on Relay:

<CardGroup cols={2}>
  <Card
    title="Instant Bridging"
    icon="bridge"
    href="https://docs.relay.link/use-cases/instant-bridging"
  >
    Get your docs set up locally for easy development
  </Card>
  <Card
    title="Cross-chain Execution"
    icon="route"
    href="https://docs.relay.link/use-cases/cross-chain-execution"
  >
    Preview your changes before you push to make sure they're perfect
  </Card>
</CardGroup>
